# Property obliges

> Eigentum verpflichtet. Sein Gebrauch soll zugleich dem Wohle der Allgemeinheit dienen. 
>
> > --- [Grundgesetz der Bundesrepublik Deutschland, Art. 14(2)]

This text is about handling resources, especially dynamic memory in C++. Warning: Don’t implement any of these techniques described here *until you have read the last two sections of this text* (standard library classes handling ownership and the Rule of Zero).

## No naked new

Consider a function

```cpp
consume(new Foo{1}, new Foo{2});
```

which takes two (pointers to) dynamically allocated objects and `delete`s them after use. 

Q: What can go wrong?

A: If one of the allocations fails and throws an exception after the other one was allocated, the other pointer will never be deleted. (We can’t tell which one is first and which one second: C++ doesn’t define the evaluation order of parameters.)

Therefore: no naked new! Resource allocation should be done in a class or struct that *owns the (one) resource* and is responsible for freeing it (`delete` memory etc.). For each `new`ed object there must be exactly one `delete`. The responsibility of the destructor is to clean up resources in a exception-safe way. It should give the resource back, otherwise there would be a *resource leak*. *Resource Allocation Is Initialization* (RAII principle) is a unfortunate name. Is should better be called *AC/DC* principle (Acquiring Constructor, Destructor Clean-up).

## Leaks, zombies and memory corruption

```cpp
class Wrong
{
    int *p_;
public:    
    Wrong(int n) : p_{new int(n)} {}
    ~Wrong() { delete p_; }
};
```

Although following the AC/DC principle, this class is fundamentally incorrect. The body of

```cpp
void crash1()
{
	Wrong a{1}; // 1
	Wrong b{2}; // 2
    a = b;      // 3
    // ...      // 4
}               // 5, 6
```

is equivalent to

```cpp
	int* p = new int(1);
	int* q = new int(2);
	p = q;     // 3
    // ...     // 4
	delete q;  // 5
	delete p;  // 6
```

* Assigning another address to `p` in line 3, the address of int(1) to is lost. You can’t access or free it anymore. There is a memory leak.
* Both pointers `p` and `q` refer to the same memory. Data are shared in a strange way between otherwise independent data, a nightmare for debugging: Writing to one referred  variable will change also the “other” since the pointers point to an identical address. 
* When memory is freed in line 5, both pointers refer to the same freed memory block. Accessing it causes *undefined behavior* (UB). Anything can happen. It should result in a *segfault* (segmentation error or access violation). 
* At line 6 the same memory block is freed again (*double delete* is UB). It’s like bringing back a beer crate with refundable deposit twice. (In Germany, typically, we do not smash or throw away empty bottles. We return them to the retailer for reuse and get cash back.)

The culprit is `a = b;` the assignment operator for classes containing pointers has to follow special rules. Copying values 

```cpp
void crash3()
{
	Wrong a{3};
	Wrong b{a}; // copies the pointer
    // ... sharing address
}   // double delete
```
leads to the same problem as using value parameters
```cpp
void use(Wrong param)
{   // ...
}

void crash4()
{
	Wrong w{4};
	use(w); // copy
	// ... pointer to deleted memory
}   // double delete
```

The `Wrong` copy constructor makes a *shallow copy*. It copies the pointer. So both variables point to the same address, and the same memory block is deleted twice: ouch!

Destructor, assignment operator, and copy constructor are called *special functions*. Automatically generated by the compiler, they do the “right thing” for values types, but not for pointers. If you have to *user-define* one of these special functions, probably you have to define all three (*Rule of Three*). Since C++11 there are also move constructor and move-assignment. So you have to consider five special functions (*Rule of Five*).

## Forbid dangerous operations

>  Was gestrichen ist, kann nicht durchfallen. 
>
> > --- [Kurt Tucholsky: Ratschläge für einen guten Redner]

Simply copying a pointer (a so-called *shallow copy*) leads to disaster. When assigning a new resource to a owning pointer, where should the old resource go to prevent a leak? 

A safe way is to `delete` dangerous operations:

```cpp
class Safe
{
	int p_;
public:
    Safe(int n) : p_{new int(n)} {}
    ~Safe() { delete p_; }
	// forbid auto generation of special functions:
    Safe(Safe const& orig) = delete;           // copy constructor 
    Safe& operator=(Safe const& rhs) = delete; // copy assignment
    Safe(Safe&& orig) = delete;                // move constructor
    Safe& operator=(Safe&& rhs) = delete;      // move assignment
};
```

There are examples of such classes in the standard library: `<iostream>` objects like `std::cin`,  `std::cout` are not copyable or assignable. Using them as function parameters and return values is possible *by reference*, not *by value*.

## Ways to handle resources properly

The owner of a resource has the obligation to decide what can be done with its property.

* Forbid any copy or transfer of ownership (deleted special functions, see above).
* Allow copying the owned structure (*deep copy*): the copy is equal in structure and values to the original, but independent from it.
* Allow transfer of ownership to another owner (*move copy* and *move assignment*), the former owner does not own the resource anymore.
* Share the owned resource with others and keep track, how many users have access to the resource (*reference counting*). Keep the resource until the last user is gone.

How to implement these rules? Here are some examples (constructors and destructor omitted for brevity).

```cpp
class Copyable{
    int *p_;
public:
    Copyable(Copyable const& orig)
    : p_{new int(orig.p_)}
    {        
    }
    Copyable& operator=(Copyable const& rhs)
    {
        Copyable tmp(rhs);
        std::swap(tmp.p_, p_);
        return *this;
    }
    // ...
};
```

`operator=` has to release the old `p_` and to get a copy of the object pointed to by `rhs.p_`. The “swapperator trick” used here is exceptionally safe. If copying `rhs.p_` would throw an exception in creating `tmp`, `*this` is not changed. The `swap()` “commits” the change after successful copying. The former resource is now owned by `tmp` and will be deleted when the lifetime of `tmp` ends at the closing brace.

Move constructor/move assignment are not automatically generated , when copy constructor/assignment are user-defined. Implement it for transfer of ownership.

```cpp
class Movable
{
    int* p_;
public:
    Movable(Movable&& orig)
    : p_{nullptr}
    {
    	std::swap(orig.p_, p_); 
    }
    Movable& operator=(Movable&& rhs)
    {
        std::swap(rhs.p_, p_);
        return *this;
    }
};
```

The resource owned by an expiring object (*rvalue reference*) is transferred. The expiring object should be in a safe state afterwards. Nobody should use its resource after the move operation. So a `nullptr` will suffice. Using it as a garbage bin for the old resource is also o.k.

When move operations are user-defined, no copy constructor/assignment operator is generated automatically.

## Standard library classes implementing ownership

* `std::string`, `std::vector<T>`, and other containers are managing dynamic memory for 0 to many (`0..n`) elements. They are (deep) copying elements and implement move operations for cheap transfer of ownership on expiring values.
* `std::optional<T>` implements value semantics for `0/1` element even without using dynamic memory, but emulates an pointer interface.
* `std::unique_ptr<T>` implements transfer of ownership, but allows no copies.
* `std::shared_ptr<T>` implements shallow copying with reference counting.

Both *smart pointer* classes `unique_ptr<T>` and `shared_ptr<T>` are capable to hold an object of inherited classes. See following texts about how to use these classes.

However, the standard library does not have a smart pointer class with deep copy semantics for inheritance. This would require all derived classes to implement a `Cloneable` interface like in Java. It’s not difficult to implement `clone_ptr<T>` yourself. It’s left here as an exercise...

## The Rule of Zero

Q: Do we have to implement all special functions of a class with a owning pointer member or handling another resource?

A: The good news is: No, if the pointer/resource is encapsulated in a member, that handles ownership itself. That’s called the *Rule of Zero*. Having a `std::vector<T>`, `std::optional<T>`, `std::unique_ptr<T>`, or `std::shared_ptr<T>` member is perfectly fine:

```cpp
struct Movable // implements transfer of ownership, no copy
{
	std::unique_ptr<int> p;
    // ...
};

struct Shared // shallow copies with ref counting
{
	std::shared_ptr<int> p;
    // ...
};
```

Since `unique_ptr<T>` is movable but not copyable, a class having such a member also is not copyable. The class can only provide automatically generated special functions, it’s members support. If that is not enough, you are free to provide them yourself. Then you have to reason about what the special function should do. 

Owning something means you have to define what can be done with your property.